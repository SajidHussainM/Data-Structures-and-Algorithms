Time Complexity

Wednesday, July 27, 2022

3:48 PM

 

How to determine the solution of a problem by looking at its constraints?

By eanacra, 7 years ago, 

 

By looking at the constraints of a problem, we can often "guess" the solution.

Common time complexities

Let n be the main variable in the problem.

If n ≤ 12, the time complexity can be O(n!).
If n ≤ 25, the time complexity can be O(2n).
If n ≤ 100, the time complexity can be O(n4).
If n ≤ 500, the time complexity can be O(n3).
If n ≤ 104, the time complexity can be O(n2).
If n ≤ 106, the time complexity can be O(n log n).
If n ≤ 108, the time complexity can be O(n).
If n > 108, the time complexity can be O(log n) or O(1).
Examples of each common time complexity

O(n!) [Factorial time]: Permutations of 1 ... n
O(2n) [Exponential time]: Exhaust all subsets of an array of size n
O(n3) [Cubic time]: Exhaust all triangles with side length less than n
O(n2) [Quadratic time]: Slow comparison-based sorting (eg. Bubble Sort, Insertion Sort, Selection Sort)
O(n log n) [Linearithmic time]: Fast comparison-based sorting (eg. Merge Sort)
O(n) [Linear time]: Linear Search (Finding maximum/minimum element in a 1D array), Counting Sort
O(log n) [Logarithmic time]: Binary Search, finding GCD (Greatest Common Divisor) using Euclidean Algorithm
O(1) [Constant time]: Calculation (eg. Solving linear equations in one unknown)
 

From <https://codeforces.com/blog/entry/21344>

 

 

Input Length

Worst Accepted Time Complexity

Usually type of solutions

10 -12

O(N!)

Recursion and backtracking

15-18

O(2N * N)

Recursion, backtracking, and bit manipulation

18-22

O(2N * N)

Recursion, backtracking, and bit manipulation

30-40

                       O(2N/2 * N)

Meet in the middle, Divide and Conquer

100

O(N4)

Dynamic programming, Constructive

400

O(N3)

Dynamic programming, Constructive

2K

O(N2* log N)

Dynamic programming, Binary Search, Sorting, 

Divide and Conquer

10K

O(N2)

Dynamic programming, Graph, Trees, Constructive

1M

O(N* log N)

Sorting, Binary Search, Divide and Conquer

100M

O(N), O(log N), O(1)

Constructive, Mathematical, Greedy Algorithms

 

From <https://www.geeksforgeeks.org/time-complexity-and-space-complexity/>
